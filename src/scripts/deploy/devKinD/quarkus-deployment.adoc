= Keycloak Configuration
Angel Casanova; Antonio Costa
:revdate: {docdate}
:toc: left
:icons: font
:description: This section describes how to move a quarkus app within a container.
:source-highlighter: rouge

This section describes how to move a quarkus app within a container.


== Necessary Extensions

These extensions will be included within the quarkus code eventually.
Up from `quarkus v3.1` they would be no longer needed.

=== Docker extension

Quarkus allow building container images from different engines, but we are going to use `Docker` as it provides us with the images in a `Dockerfile` format.

[source,groovy]
----
implementation 'io.quarkus:quarkus-container-image-docker'
----

[NOTE]
====
You can use other engines to build up your images.
For instance, you can use`implementation("io.quarkus:quarkus-container-image-jib")`
====

=== Kubernetes extension

It is necessary to generate the kubernetes `Deployment.yaml file`.

[source,groovy]
----
implementation("io.quarkus:quarkus-kubernetes")
----

=== Kubernetes config extension

It is use in order to use variables from configmap and secret in the quarkus application properties.

[source,groovy]
----
implementation 'io.quarkus:quarkus-kubernetes-config'
----

=== Helm chart extension

Use only up from quarkus `v3`.

[source,groovy]
----
implementation([group: 'io.quarkiverse.helm', name: 'quarkus-helm', version: '1.0.1'])
----

== Generating the image

[IMPORTANT]
====
All the steps below will be deprecated up from version 3. All deployments should be done throughout the quarkus client.
====

[IMPORTANT]
====
Some of the paparemeters are has been excluded from the commands since they are defined in the K8S section within the `application.properties` file.
====

Then we just need to build the project with the proper flag:

[source,bash]
----
./gradlew clean build \
  -x test \
  -Dquarkus.container-image.build=true
----

== Pushing the image

To push a container image for your project, quarkus.container-image.push=true needs to be set using any of the ways that Quarkus supports.

[source,bash]
----
./gradlew build \
  -x test \
  -Dquarkus.container-image.push=true \
  -Dquarkus.container-image.registry="localhost:5000"
----

[NOTE]
====
If no registry is set (using quarkus.container-image.registry) then docker.io will be used as the default.
====

== Generate the kubernetes manifest for the init container

We need to populate the database in or der to use our application, so the easiest way of doinf that, is to launch the demo loader beforehand.
We can do it with a init container in kubernetes.

[source,bash]
----
./gradlew clean cleanBuild build \
  -x test -x checkstyleMain -x checkstyleTest -x checkstyleNativeTest -x pmdMain -x pmdTest \
  -Dquarkus.container-image.build=true \
  -Dquarkus.container-image.name="itwm-bl-demo" \
  -Dquarkus.container-image.push=true \
  -Dquarkus.container-image.registry="localhost:5000" \
  -Dquarkus.kubernetes.deploy=false \
  -Dquarkus.docker.dockerfile-jvm-path="src/main/docker/Dockerfile-demo.jvm"
----

[NOTE]
====
The path to the Dockerfile need to be relative to the project root or absolute to the filesystem.
====

[#container-image-creation]
== Generate the kubernetes manifest

Using the flag `-Dquarkus.kubernetes.deploy=true` we can generate a `.yaml` file that contains everything in order to deploy our application in k8s.

So, if we want to generate a fresh image build, push it to some registry and generate the link:../../../../build/kubernetes/kubernetes.yml[kubernetes yaml file]

[source,bash]
----
./gradlew clean cleanBuild build \
  -x test -x checkstyleMain -x checkstyleTest -x checkstyleNativeTest -x pmdMain -x pmdTest \
  -Dquarkus.container-image.build=true \
  -Dquarkus.container-image.push=true \
  -Dquarkus.container-image.registry="localhost:5000" \
  -Dquarkus.kubernetes.deploy=true
----

It is also possible(but it is not necessary) to build it on dev mode:

[source,bash]
----
./gradlew clean cleanBuild build \
  -x test -x checkstyleMain -x checkstyleTest -x checkstyleNativeTest -x pmdMain -x pmdTest \
  -Dquarkus.container-image.build=true \
  -Dquarkus.container-image.push=true \
  -Dquarkus.container-image.registry="localhost:5000" \
  -Dquarkus.kubernetes.deploy=true \
  -Ddebug=true \
  -Dquarkus.profile=dev
----

== Simple queries with curl

With the queries is easy to test the connectivity of the container.

=== Get some user's token

Remember to start the keycloak container before attempting to request the token.
It is necessary to request the `access_token` from inside the keycloak container since otherwise the request will be resolved as `401`(Unauthorized) sue to the Issuer's claim.
That is, you are requesting access from a different source.

[source,bash]
----
export TKN=$( \
  kubectl -n twm -c keycloak exec -it \
  $(kubectl -n twm get pods | grep keycloak | awk '{print $1}') -- \
    curl -sX POST 'http://localhost:8080/auth/realms/trikorasolutions/protocol/openid-connect/token' \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d 'client_secret=6e521ebe-e300-450f-811a-a08adc42ec4a' \
    -d 'grant_type=password' \
    -d 'username=tkraab@trikora_solutions' \
    -d 'password=tkraab@trikora_solutions' \
    -d 'client_id=backend-service'  | jq -r '.access_token')
----

=== Use the token to request anything

[source,bash]
----
curl --verbose \
  -H "Authorization: Bearer ${TKN}" \
  -H "Content-Type: application/json" \
  -X OPTIONS http://localhost:31070/api/core/party/stream/notification | jq .
curl --verbose \
  -H "Authorization: Bearer ${TKN}" \
  -H "Content-Type: application/json" \
  -X OPTIONS http://localhost:31070/api/core/party/stream/notification
----

=== Get UserInfo from the KC container

[source,bash]
----
kubectl -n twm -c keycloak exec -it \
$(kubectl -n twm get pods | grep keycloak | awk '{print $1}') -- \
  curl --verbose \
    -H "Authorization: Bearer ${TKN}" \
    -H "Content-Type: application/json" \
    -H "Accept: application/json" \
    -d "username=tkraab@trikora_solutions" \
    -d "exact=true" \
    -X GET http://localhost:8080/auth/admin/realms/trikorasolutions/users
----

=== Get Token from the Quarkus container

[source,bash]
----
export TKN=$( \
  kubectl -n twm -c itwm-bl exec -it \
  $(kubectl -n twm get pods | grep bl | awk '{print $1}') -- \
    curl -sX POST 'http://keycloak.twm.svc.cluster.local/auth/realms/trikorasolutions/protocol/openid-connect/token' \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d 'client_secret=6e521ebe-e300-450f-811a-a08adc42ec4a' \
    -d 'grant_type=password' \
    -d 'username=tkraab@trikora_solutions' \
    -d 'password=tkraab@trikora_solutions' \
    -d 'client_id=backend-service'  | jq -r '.access_token')
----

=== Get UserInfo from the Quarkus container

[source,bash]
----
kubectl -n twm -c itwm-bl exec -it \
$(kubectl -n twm get pods | grep itwm-bl | awk '{print $1}') -- \
  curl --verbose \
    -H "Authorization: Bearer ${TKN}" \
    -H "Content-Type: application/json" \
    -H "Accept: application/json" \
    -d "username=tkraab@trikora_solutions" \
    -d "exact=true" \
    -X GET http://keycloak.twm.svc.cluster.local:8080/auth/admin/realms/trikorasolutions/users
----

== References

* link:https://quarkus.io/guides/container-image[Creating Quarkus Images for Containers]
* link:https://access.redhat.com/documentation/de-de/red_hat_build_of_quarkus/1.7/html/deploying_your_quarkus_applications_as_openshift_serverless_services/proc-deploy-container-image-quarkus-native_deploy-quarkus-openshift-serverless[Red Hat Work Around]
* link:https://es.quarkus.io/guides/deploying-to-kubernetes[Quarkus Kubernetes extension]
* link:https://quarkus.io/guides/config-extending-support#custom-config-source[Extending configuration to Dependencies]
* link:https://es.quarkus.io/guides/rest-client[Info about the rest client properties]
